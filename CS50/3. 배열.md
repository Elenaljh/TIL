# 3. 배열
## 1. 컴파일링(Compiling)
```
#include <cs50.h>
#include <stdio.h>

int main(void)
{
	string name = get_string("What's your name?\n")
	printf("hello, %s\n", name)
}
```
이 코드를 컴파일해보자. 컴파일링은 다음 명령어를 입력하면 실행된다.
`clang -o hello hello.c -lcs50`
`make hello`
컴파일은 소스코드를 오브젝트코드(기계어)로 변환시키는 과정인데, 총 4단계로 이뤄진다. 
### 1. 전처리 (Preprocessing)
코드 맨 위의
```
#include <cs50.h>
#include <stdio.h>
```
는 cs50, stdio 라이브러리의 헤더파일들이다. 컴파일러는 이 라이브러리에 들어가서 hello.c 코드에서 사용하는 함수 프로토타입을 복사해서 붙여넣는다. 그럼 위의 #include ~ 코드는 이렇게 바뀐다. (여전히 소스코드 형태임)
```
string get_string(string prompt);
int printf(string format, ...);
```
### 2. 컴파일 (Compiling)
전처리(1단계)가 완료된 코드
```
string get_string(string prompt);
int printf(string format, ...);

int main(void)
{
	string name = get_string("What's your name?\n")
	printf("hello, %s\n", name)
}
```
컴파일링 단계를 거치면 소스코드가 어셈블리어로 바뀐다.
```
main:									# @main
		.cfi_startproc
# BB#0:
	pushq	%rbp
.Ltmp0:
		.cfi_def_cfa_offset 16
.Ltmp1:
		.cfi_offset %rbp, -16
		movq	%rsp, %rbp
.Ltmp2:
		.cfi_def_cfa_register %rbp
		subq	$16, %rsp
		xorl		%eax, %eax
		movl	%eax, %edi
		movabsq		$.L.str, %rsi
		movb	$0, %al
		callq	get_string
		movabsq		$.L.str.1, %rdi
		movq %rax, -8(%rbp)
		...
```
이 어셈블리 코드에서 pushq, movq, subq, xorl 등의 언어들은 '명령어'인데, CPU가 알아들을 수 있는 언어에 가깝다.
### 3. 어셈블 (Assembling)
위의 어셈블리 코드를 머신코드로 바꾸는 과정이다. 
```
0111111001010100111010101100001100000
1001001110101101110101101111001011110
1010100001111110011011010101001010000
...
```
위와 같은 머신코드로 바뀐다. 만약 컴파일할 파일이 하나뿐이라면 컴파일링은 이 단계에서 완료.
### 4. 링크 (Linking)
hello.c에는 cs50.c, stdio.c, hello.c(내가 작성한 코드)의 3가지 파일이 사용된다. (cf. stdio.c 안의 printf.c파일과 cs50.c 안의 get_string.c파일 사용) 
이런 경우에는 컴파일링 과정에서 세 파일을 연결해야 하는데 이를 링킹이라고 한다. 즉, 기계어로 번역된 세 파일을 하나의 오브젝트 파일로 뭉치는 과정이다. 

## 2. 디버깅 
### 1. help50
주의: 이 기능은 cs50라이브러리의 기능이라 일반적으로 사용하기엔 제한적일 수 있다. 문법 오류(syntax error)에 사용한다. 
```
int  main(void)
{
printf("Hello, world.\n");
}
```
이걸 컴파일하면 에러 발생. 터미널창에
```
help50 make buggy1
```
라고 치면 
```
Asking for help...

buggy1.c:3:5: error: implicitly declaring library function 'printf' with type 'int (const char *, ...)' [-Werror,-Wimplicit-function-
declaration]
    printf("Hello, world.\n");

Did you forget to #include <stdio.h> (in which printf is declared) atop your file?
```
이라고 도움말이 노란색으로 뜬다. 
### 2. printf()
논리오류 발생시 사용한다. ex. #을 10번 출력하고 싶은데 11번 출력되는 경우
```
#include  <stdio.h>

int  main(void)
{
	for(int i=0;i<=10;i++)
	{
		printf("i is now %i\n", i); //디버깅 장치
		printf("#\n");
	}
}
```
커맨드창에는 이런 출력물이 뜬다. 
```
$ ./buggy2
i is now 0
#
i is now 1
#
i is now 2
#
i is now 3
#
i is now 4
#
i is now 5
#
i is now 6
#
i is now 7
#
i is now 8
#
i is now 9
#
i is now 10
#
```
이렇게 for 구문에서 `i<=10`을 `i<10`으로 바꿔야 함을 알 수 있다.
### 3. debug50
ide.cs50.io에서 실행
![ide의 환경은 다음과 같음](https://ibb.co/QJDJg4G)

