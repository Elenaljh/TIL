# 6. 자료구조
## 1. malloc과 pointer 복습
### 1. 포인터변수와 쓰레기값(garbage value)
```c
#include  <stdio.h>
#include  <stdlib.h>

int  main(void)
{
	int *x;
	int *y;

	x = malloc(sizeof(int)); // 주석1

	*x = 42;
	*y = 13;  // 주석2
}
```
- 주석
	1. malloc: 할당된 메모리의 첫 바이트 주소를 되돌려줌, 메모리가 부족한 경우 NULL 반환.
	2. **컴파일시 여기에서 문제 발생**. `error: variable 'y' is uninitialized when used here` 포인터 y는 선언했으나, malloc을 이용해 메모리를 할당하지 않았기 때문에 쓰레기값(garbage value)이 저장된다. 이건 굉장히 위험한 상황인데, 그림으로 표현해보면 다음과 같다. 
<img src = "https://i.esdrop.com/d/f/Hn3cQpRVXY/flh4meL3EN.gif"/>

위의 코드를 옳게 바꾸면 다음과 같음. 
```c
#include  <stdio.h>
#include  <stdlib.h>

int  main(void)
{
	int *x;
	int *y;

	x = malloc(sizeof(int)); 

	*x = 42;
	y = x; //추가 
	*y = 13; 
}
```
이 경우  x와 y는 동일한 메모리 주소값을 가지게 됨. 따라서 *x에는 42가 저장되었다가 13이 다시 저장되게 된다 (*y때문에). 어쨌든 오류는 발생하지 않음. 
### 2. 쓰레기값 방지하는 법
1. malloc을 이용해 따로 메모리를 할당하고 거기에 포인터 연결 ex. `int *a = malloc(sizeof(int));`
2. 포인터변수 선언시 NULL을 이용해 값을 초기화하기 ex. `int *a = NULL;` 

### 3. 참조와 역참조
1. 참조(&) 
포인터에 메모리 주소를 저장하는 것
2. 역참조(*)
포인터에 저장된 주소로 가서 그 곳에 저장된 값에 접근하는 것. 

### 4. 생각해보기
:bulb: 포인터를 초기화시키지 않고 값을 저장하면 어떤 오류가 발생할 수 있을까요?  
포인터변수에 메모리 주소가 랜덤으로 저장되는데(쓰레기값), 운이 나쁘면 운영체제파일같은 중요한 정보가 저장된 메모리 주소가 포인터변수에 저장될 수 있다. 그 정보를 다른 정보로 덮어쓰기하는 경우 시스템에 중대한 오류가 발생할 수 있다. 

## 2. 배열의 크기 조정하기
:pushpin: **핵심 단어: malloc, realloc**    

### 1. 배열의 크기 키우기
일정한 크기의 배열이 주어졌을 때, 그 크기를 키우려면 어떻게 해야할까?  
단순히 현재 배열이 저장되어있는 메모리 위치의 바로 옆에 일정 크기의 메모리를 더 덧붙이면 되는 것 같지만, 실제로는 그 옆에 다른 데이터들이 저장되어있을 확률이 높다. 따라서 안전하게 **새로운 공간에 메모리를 다시 할당**하고 기존 배열의 값들을 하나씩 옮겨줘야 한다.
<img src = "https://i.esdrop.com/d/f/Hn3cQpRVXY/yqmz3UpSw2.gif"/>
이 작업은 **O(n)**, 즉 배열의 크기 n만큼의 실행 시간이 소요된다. 
<img src = "https://i.esdrop.com/d/f/Hn3cQpRVXY/aPQrqDeqpN.jpg"/>

### 2. malloc을 이용해 배열의 크기 키우기
```c
#include  <stdio.h>
#include  <stdlib.h>  //malloc, free 함수가 저장되어있음

int  main(void)
{
	//int 자료형 3개로 이루어진 list라는 포인터를 선언하고 메모리 할당
	int *list = malloc(3 * sizeof(int));

	//안전성 점검(malloc은 메모리가 부족하면 NULL을 반환한다)
	if (list == NULL)
	{
		return  1; // 만약 malloc이 NULL을 반환했다면(메모리가 부족) 프로그램을 종료한다
	}

	//list배열의 각 인덱스에 값 저장
	list[0] = 1; //각주 4 참고
	list[1] = 2;
	list[2] = 3;

	//int 자료형 4개 크기의 tmp라는 포인터를 선언하고 메모리 할당	
	int *tmp = malloc(4 * sizeof(int));  //주석 5 참고

	if (tmp == NULL)
	{
		return  1;
	}

	//list의 값 tmp로 복사
	for (int i = 0; i < 3; i++)
	{
		tmp[i] = list[i]; //할당된 새 메모리 덩어리(tmp)를 배열처럼 대괄호 써서 사용 가능
	}

	//tmp배열의 네 번째 값도 저장
	tmp[3] = 4;

	//기존 메모리(list) 해제
	free(list);

	//tmp 이름 계속 쓰는건 좀 바보같으니까 list로 이름 바꾸기
	list = tmp; 

	//새로운 배열 list의 값 확인
	for (int i = 0; i < 4; i++)
	{
		printf("%i\n", list[i]);
	}

	//프로그램이 끝나기 전 list의 메모리 초기화
	free(list); 
}
```
1. 헤더 파일 안넣으면 나오는 에러: **implicitly declaring library function** 'malloc' with type 'void * 어쩌고 저쩌고..
2. malloc은 포인터를 반환하지만 메모리 덩어리를 할당하기 때문에 배열과 비슷하게 대괄호 기호[]를 사용할 수 있다. 그 이유는 배열도 메모리 덩어리이기 때문이다. 이렇게 보면 포인터 개념(malloc)과 배열이 동일한 것이라고 착각할 수 있다.   
그러나 배열은 자동으로 free(기존 메모리 해제)가 되지만 malloc은 그렇지 않기 때문에 이런 차이점은 주의해야 한다. 
3. malloc이나 realloc으로 메모리를 할당받을 때마다 널이 반환되었는지 확인해보는 습관을 들여야 한다.
4. 포인터 이름 옆에 대괄호를 쓰면 (ex. a[i]) 컴퓨터는 자동으로 (포인터 주소 + i*sizeof(자료형)) 주소로 이동. 
ex. int의 크기는 4바이트 -> 따라서 list[1] 주소 = list[0] 주소 + 4bytes
<img src = "https://i.esdrop.com/d/f/Hn3cQpRVXY/h0HcL2SC0R.png" width = "500"/>
5. 만약 임시변수(tmp)를 안만들고 바로 list = malloc~~ 이라는 코드를 넣으면 기존 정보는 포인터를 잃고 컴퓨터 메모리 안을 떠돌게 된다.. 물론 우린 이제 그 정보들을 찾을 수 없음ㅋㅋㅋ

솔직히 위의 코드는 너무 길다. **tmp에 메모리 할당**하고, **list의 원소들을 tmp에 옮기고**, **내용 추가**하고, 마지막에 **기존 메모리 free**하는 과정을 하나로 합친 함수가 있다: **realloc (re-allocate the chunk of memory)**

### 3. realloc을 이용해 배열의 크기 키우기
```c
#include  <stdio.h>
#include  <stdlib.h>

int  main(void)
{
	int *list = malloc(3 * sizeof(int));
	if (list == NULL)
	{
		return  1;
	}

	list[0] = 1;
	list[1] = 2;
	list[2] = 3;

	//tmp포인터에 메모리를 할당하고 list의 값 복사
	int *tmp = realloc(4 * sizeof(int)); //realloc 사용 - 각주 참고
	
	// 안전장치 - 메모리 있는지 검사
	if (tmp == NULL)
	{
		return  1;
	}

	//tmp 변수명을 list로 변경
	list = tmp;

	//새로운 list의 네 번째 값 저장
	list[3] = 4;
  
	//list의 값 확인
	for (int  i = 0; i < 4; i++)
	{
		printf("%i\n", list[i]);
	}
 
	//list의 메모리 초기화
	free(list);
}
```
**realloc은...**
1. 이미 할당받은 기존 메모리 덩어리를 새롭게 가져오고 원래보다 크든 작든 새롭게 설정된 크기로 바꾸는 일을 한다.  
2. realloc은 기존 배열에서 새로운 배열로 데이터를 복사해주고, 기존 메모리는 자동으로 해제해줌-free(기존 배열)
3. 우리들은 뭔가 잘못되지는 않았는지(realloc이 NULL값을 반환하는지) 체크하고 잘못된 것이 없다면 새로운 배열에 새로운 값을 추가적으로 저장하면 됨

### 4. 생각해보기
:bulb: 이미 할당된 메모리의 크기를 조절할 때 임시 메모리를 새로 할당해줘야 하는 이유는 무엇인가요?  
만약 임시변수(tmp)를 안만들고 바로 list = malloc~~ 이라는 코드를 넣으면 기존 정보는 포인터를 잃고 컴퓨터 메모리 안을 떠돌게 된다. 그럼 우린 이제 그 정보들을 찾을 수 없게 된다..

## 3. 연결 리스트: 도입
:pushpin: **핵심 단어: 연결 리스트**  
:pushpin: **복습: [구조체](https://github.com/Elenaljh/TIL/blob/main/CS50/4.%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.md), [포인터](https://github.com/Elenaljh/TIL/blob/main/CS50/5.%20%EB%A9%94%EB%AA%A8%EB%A6%AC.md)**  

### 1. 데이터 구조란
데이터구조는 우리가 컴퓨터 메모리를 더 효율적으로 관리하기 위해 새로 정의하는 구조체(structure)이다. C에서 자료구조(데이터구조)는 아래 3가지 문법으로 이뤄진다.
|문법|설명|
|---|---|
|struct|구조체. 비트맵이나 비트맵 헤더 등과 관련된 문제에서도 구조체 사용|
|.|구조체의 속성값에 접근할 때 사용|
|*|역참조 연산자|

### 2. 연결 리스트 (Linked list)
#### 1. 배열
배열은 **1. 데이터 수정시 느리**지만 **2. 데이터에 접근할 때는 빠르**다.
우선, 배열의 길이를 늘리거나 줄이기 위해서는 앞에서 배운대로 malloc이나 realloc을 이용해 메모리를 새로 할당받고, 기존 배열의 내용을 복사해서 새로운 배열에 붙여넣은 후 새 내용을 추가하거나 지우고, 마지막으로 기존 배열은 free를 통해 메모리를 해제시켜줘야 한다. 이 과정의 시간복잡도는 **O(n)** 으로 느리다.  
그러나, 배열은 쉽게 인덱싱할 수 있어 값에 접근하는 것이 쉽고 빠르다. 또한 **랜덤 접근**이라는 방법으로 일정한 시간에 값에 접근할 수 있다(**constant time access**). 이런 면에서 배열은 매우 빠르다. 
<details>
<summary> **constant time access란?** </summary>

"Every point in array is accessible in *constant* time."   
우리는 배열에 포인터(메모리 주소)로 접근한다. 즉, 주소를 알기만 하면 별다른 과정을 거치지 않고도 바로 그 곳으로 갈 수 있는 것이다. 예를 들면  
`a[3] == *(location of a + n*sizeof(int))`  
인 것이다. 따라서 배열의 어느 위치에 접근해도 동일한 시간(constant time)이 소요된다.  
이에 반해 **연결 리스트(Linked list)** 는 데이터의 수에 따라 값에 접근하는 시간이 달라진다 (**accessible in "linear" time.**). 연결 리스트에서 n번째 값에 접근하기 위해서는 n-1개의 원소를 거쳐야 하기 때문이다.
</details>

#### 2. 연결 리스트
<img src = "https://cs50.harvard.edu/x/2020/notes/5/linked_list_with_addresses.png"/>
연결 리스트의 형태는 위와 같다. 연결 리스트의 값들은 배열처럼 값이 서로 붙어있지 않다.(따라서 배열처럼 대괄호[]를 사용해 값에 접근할 수 없다.)   

메모리의 빈 공간에 여기저기 값이 흩어져 있는 대신, **하나의 값**에는 **다음 값의 주소(포인터)** 가 붙어있는 것이 **연결 리스트의 특징**이다. 포인터의 역할은 연결 리스트의 각 값을 연결하는 것이며, 리스트의 **맨 마지막 값에는 NULL 포인터**가 붙어있다.   

<details>
<summary> **참고: NULL과 NUL** </summary> 

|종류|자료형|특징|
|---|---|---|
|NULL|pointer|값: 0x0|
|NUL|char|\0(널문자)|
</details>

위 그림에서 값+포인터를 저장한 두 칸이 한 덩어리로 그려져 있는데, 이 덩어리를 **node**라고 한다. 

### 3. 구조체로 연결 리스트 정의하기

<details>
<summary>구조체 복기</summary>

```c
typedef struct
{
	string name;
	string number;
}
person;
```
person이라는 자료형을 만들었었음. 구조체의 멤버 변수(member variable)은 name과 number임.
각 멤버 변수에는 `person.name`, `person.number`과 같이 `.`을 사용해 접근한다. 
</details> 

연결 리스트는 아래 코드와 같이 간단한 구조체로 정의할 수 있다.

```c
typedef struct node  //struct node: 구조체의 정식 명칭 (formal name of structure)
{
    int number;
    struct node *next; //next라는 포인터는 node structure을 가리키도록 정의됨
}
node; //구조체의 별명(alias). typedef가 하는 일은 프로그램의 다른 부분에서 사용하기 쉽도록 node를 node structure의 별칭으로 사용하도록 정의하는 것이다. (It gives you an alias from struct node to just 'node')
```
node라는 이름의 구조체는 number와 *next 두 개의 필드가 함께 정의되어 있다.  
number은 **각 노드가 가지는 값**, *next는 **다음 node를 가리키는 포인터**가 된다.   
여기에서 `typedef struct` 대신 `typedef struct node`라고 'node'를 함께 명시해주는 것은, 구조체 안에서 node를 사용하기 위해서이다. 

<details>
<summary> 참고 </summary>

```c
typedef struct x
{
	int number;
	struct x *next;
}
node;  //struct x의 별칭
```
이런 식으로 코드를 작성해도 위의 struct node를 정의한 것과 동일한 결과가 나온다. 
</details>

### 4. 생각해보기 
:bulb: 연결 리스트를 배열과 비교했을 때 장단점은 무엇이 있을까요?    
**데이터의 접근, 탐색이 중요하다면 배열을 쓰자.**  
**데이터의 추가, 삭제가 중요하다면 연결리스트를 쓰자.**  

#### 1. 배열 vs 연결리스트
||배열|연결 리스트|
|---|---|---|
|개념|**정적(static)인 자료구조**로, **연속된 메모리 주소**를 할당받음. **스택**에 메모리가 할당됨. **크기 수정이 불가**하고, 배열 크기 이상의 데이터 저장 불가. 그러나 데이터가 **순차적으로 저장**되기 때문에 인덱스를 사용할 수 있어 **임의 접근(random access)** 가 가능해짐|크기를 정할 필요가 없어 **동적(dynamic)인 자료구조**임. **힙**에 메모리가 할당됨. 메모리 상 흩어진 노드들의 묶음인데, 각 노드에는 데이터와 다음 데이터를 가리키는 포인터(메모리 주소)가 저장됨. **크기에 제한이 없어 데이터 추가, 삭제가 굉장히 자유롭다**. 그러나 배열처럼 연속적인 메모리 주소를 할당받지 않기 때문에 **임의접근이 불가능**하고, **순차 접근(sequential access)** 방식으로 데이터를 탐색함. 트리구조를 만들때 많이 사용됨.|
|읽기|O(1)|O(N)|
|검색|O(N)|O(N)|
|삽입|O(N)/ 앞:O(N), 뒤:O(1)|O(N)/앞:O(1) , 뒤:O(N)|
|삭제|O(N)/ 앞:O(N), 뒤:O(1)|O(N)/앞:O(1) , 뒤:O(N)|
1. 읽기: 배열은 인덱스(주소)만 찾아가면 되므로 딱 한 단계만 필요하고, 연결 리스트에서는 각 노드를 거치면서 주소를 찾아야 하므로 최악의 경우 N단계가 필요함. 
2. 검색: 검색은 어떤 데이터를 찾고 그 인덱스를 얻는 것이다. 배열과 리스트 모드 검색하고 있는 값을 찾을 때까지 모든 셀(노드)를 확인해야 한다.
3. 삽입
	- 배열
		- 맨 뒤가 아닌 자리에 삽입할 때는 자료를 오른쪽으로 옮겨야 하므로 N단계가 필요함. 
		- 맨 끝에 자료를 삽입할 때는 단순히 삽입하면 되므로 1단계만 필요
	- 연결리스트 (데이터 삽입 자체는 O(1))
		- 맨 앞이 아닌 자리에 삽입할 때는 원하는 자리에 갈때까지의 노드를 거쳐야 하기 때문에 N단계를 거침. 
		- 맨 앞에 삽입할 때는 그냥 삽입하면 되므로 1단계만 필요.
4. 삭제
	- 배열
		- 맨 뒤를 삭제하는 것은 O(1)
		- 맨 뒤가 아닌 자료를 삭제할 때는 나머지 데이터를 모두 왼쪽으로 옮겨야 함. O(N)
	- 연결리스트
		- 맨 앞을 삭제하는 것은 O(1) 
		- 맨 앞이 아닌 자료를 삭제할 때는 그 노드까지 가려면 앞의 모든 노드를 거쳐야 함. O(N)


연결리스트는 노드 덕분에 데이터의 추가, 삭제로부터 자유롭지만 탐색이 느림  
배열은 데이터가 연속적이므로 탐색이 빠르지만 데이터의 추가, 삭제로부터 자유롭지 못함. 따라서 결론은 다음과 같다.  
**데이터의 접근, 탐색이 중요하다면 배열을 쓰자.**  
**데이터의 추가, 삭제가 중요하다면 연결리스트를 쓰자.**  

cf. 일반적인 알고리즘 문제를 풀 때는 배열이 더 빠르고 편하다.(문제에서 N의 크기가 주어지기 때문) 또한 배열의 크기를 초반에 MAX로 잡는다면 배열이 더 빠르고 편리함(연결리스트는 요소를 삽입, 삭제할 때마다 메모리의 할당, 해제가 일어나는데, **시스템 콜(System call)**을 사용하는 경우 시간이 꽤 소요되기 때문)

#### 2. 연결리스트의 종류
1. 일반적인 연결리스트 (Linear/Singly linked list)
	- 뒤로만 탐색 가능
	- 각 노드에 데이터와 다음 노드의 주소 저장
2. 이중 연결 리스트 (Doubly linked list)
	- 전/후로 탐색 가능
	- 각 노드에 데이터, 이전 노드의 주소, 다음 노드의 주소 저장
	- 얻고자 하는 데이터의 위치가 tail에 가깝다면 tail에서부터 역방향으로 탐색 가능하기 때문에 탐색시간을 줄일 수 있다. 
3. 원형 연결 리스트 (Circular linked list)
	- 마지막 노드가 null을 저장하는 대신 처음 노드의 주소를 저장
	- head에서부터 순회를 진행하다보면 다시 head로 돌아오는 구조. 
	- 이중 연결 리스트 + 원형 연결 리스트 = 이중 원형 연결 리스트 


## 4. 연결리스트: 코딩
### 1. 연결리스트 순차적으로 추가하기
[다른 사람의 코드 참고](https://yjg-lab.tistory.com/118)
<details>
<summary> segfault 오류 나는 코드 </summary>

```c
#include  <stdio.h>
#include  <stdlib.h>

int  main(void)
{
	//node 구조체 정의
	typedef  struct  node
	{
		int  number;
		struct  node *next;
	}
	node;

	//리스트의 첫번째 노드 가리킬 포인터(list) 정의하기
	node *list = NULL;
  
	//리스트의 첫번째 노드 만들고 값 입력하기
	node *n = malloc(sizeof(node));
	if (n == NULL)
	{
		printf("메모리 부족");
		return  1;
	}
	n  -> number = 2; //(*n).number = 2;와 동일한 의미
	n  -> next = NULL;

	//list에 첫번째 노드 주소 입력
	list = n;
	printf("%i->",n->number);
	free(n);  //이것때문에 segfault 발생

	//리스트의 두번째 노드 만들고 값 입력하기
	n = malloc(sizeof(node));
	if (n == NULL)
	{
		printf("메모리 부족");
		return  1;
	}
	n  -> number = 4;
	n  -> next = NULL;

	//첫번째 노드와 두번째 노드 연결하기
	//step1. 첫번째 노드에서 출발해서 추가한 노드의 직전 노드에 방문하기(순차적 접근)
	node *tmp = list;
	while (tmp->next != NULL)
	{
		tmp = tmp->next;
	}

	//step2. 직전 노드와 추가한 노드 이어주기
	tmp->next = n;
	printf("%i->",n->number);
	free(n);   //이것때문에 segfault 발생
}
```

망한 이유: **malloc으로 할당한 메모리 n을 노드 하나 만들고 바로 free로 풀면 다음번에 malloc으로 메모리를 할당할 때, 전에 할당한 메모리를 다시 할당해버린다.** 따라서 노드가 새로 만들어지는 것이 아니라 전에 만들었던 노드 위에 새로운 정보를 덮어쓰는 것이 되어버린다. 그래서 노드를 아무리 많이 만들어도 결과적으로 하나밖에 존재하지 않게 되고, 해당 노드의 next 필드는 NULL을 가리키게 된다. 그리고 3번째 노드(실제로는 존재하지 않지만 내가 생각하기에 3번째 노드)에 접근하려고 while문이나 for문을 돌렸을 때, n->next에 저장된 NULL값으로 가게 되어 segfault가 생긴다.   
결론적으로 동적할당한 메모리를 해제하는 free는 프로그램이 끝나기 전에 넣거나 아예 해당 변수를 이후에 쓰지 않게 될 때 넣는 것이 좋다.
</details>
<details>
<summary> segmentation fault가 발생하는 이유 </summary>

1. 보호된 메모리에 접근할 때     
2. 읽기 권한이 없는 프로세스가 읽거나 쓰려고 할 때
3. 할당된 메모리 이외 메모리에 접근할 때
</details>   

잘 되는 코드
```c
#include  <stdio.h>
#include  <stdlib.h>

int  main(void)
{
	//node 구조체 정의
	typedef  struct  node
	{
		int  number;
		struct  node *next;
	}
	node;
  
	//리스트의 첫번째 노드 가리킬 포인터(list) 정의하기
	node *list = NULL;
  
	//리스트의 첫번째 노드 만들고 값 입력하기
	node *n = (node*)malloc(sizeof(node));
	if (n == NULL)
	{
		printf("메모리 부족");
		return  1;
	}
	n  -> number = 2; //(*n).number = 2;와 동일한 의미
	n  -> next = NULL;

	//list에 첫번째 노드 주소 입력
	list = n;
	printf("%i->",n->number);

	//리스트의 두번째 노드 만들고 값 입력하기
	n = (node*)malloc(sizeof(node));
	if (n == NULL)
	{
		printf("메모리 부족");
		return  1;
	}
	n  -> number = 4;
	n  -> next = NULL;

	//첫번째 노드와 두번째 노드 연결하기
	//step1. 첫번째 노드에서 출발해서 추가한 노드의 직전 노드에 방문하기(순차적 접근)
	node *tmp = list;
	while (tmp->next != NULL)
	{
		tmp = tmp->next;
	}

	//step2. 직전 노드와 추가한 노드 이어주기
	tmp->next = n;
	printf("%i->",n->number);

```
<img src = "https://i.esdrop.com/d/f/Hn3cQpRVXY/IzoARfsPDH.gif"/>  

### 2. 연결리스트 중간에 자료 삽입
```c
//리스트 중간에 새로운 노드 삽입하기
//새로운 노드 만들기 (첫번째 노드와 두번째 노드 사이에 삽입할 것)

n = (node*)malloc(sizeof(node));
if (n == NULL)
{
	return  1;
}
n  -> number = 1;
n  -> next = NULL;

//포인터 연결하기
//step1. 새로운 노드와 그 다음 노드 연결하기
tmp = list;
for (int  i = 0; i < 1; i++)
{
	tmp = tmp->next;
}
n->next = tmp;
  
//step2. 새로운 노드와 그 전 노드 연결하기
tmp = list;
tmp->next = n;

//잘 연결됐나 확인
printf("\n");
for (tmp = list; tmp != NULL; tmp = tmp->next)
{
	printf("%i ->", tmp->number);
}
printf("NULL\n");
```

<img src = "https://i.esdrop.com/d/f/Hn3cQpRVXY/opEEgNKK6Q.gif"/>    

:pushpin:**주의**  
노드를 중간에 삽입할 때는 무조건 뒷 노드를 연결한 후에 앞 노드와 연결해야 함. 다짜고짜 앞 노드부터 연결하면 앞 노드와 뒷 노드의 연결이 끊겨서 뒤쪽 리스트 전체가 날라간다. => **메모리 누수(Memory leak)**   
<img src = "https://i.esdrop.com/d/f/Hn3cQpRVXY/lOhmTHFRCg.jpg" width = "500" />

### 3. 연결리스트 중간에 추가했던 노드(두번째 노드) 삭제
```c
//두번째 노드 삭제하기
node *pre = list;
node *remove = list;

// for (int i = 0; i < n-2; i++){pre = pre->next} => 지우고자 하는 (n번째)노드 바로 전의 노드를 pre가 가리키도록 함. 지금의 경우 n=2여서 이 과정 생략
remove = pre->next;
pre->next = remove->next; //n-1번째 노드와 n+1번째 노드 연결
free(remove); //n번째 노드 삭제

//잘 됐는지 확인해보기
printf("\n노드 삭제 결과: ");
for (tmp = list; tmp != NULL; tmp = tmp->next)
{
	printf("%i ->",tmp->number);
}
printf("NULL\n");
```



### 4. 생각해보기
:bulb: 연결 리스트의 중간에 node를 추가하거나 삭제하는 코드는 어떻게 작성할 수 있을까요?    
3번에서 작성한 코드 참고





