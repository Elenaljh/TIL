# 3. 배열 단원 추가 내용
## 1. 생각해보기 문제
:pushpin: **7단원** string.h와 ctype.h의 라이브러리에 다른 어떤 함수가 있는지 확인해 보고, 어떤 함수를 어떻게 활용해 볼 수 있을지 생각해봅시다.
자세한 함수는 위키 참고
1. ctype.h
1.1. 문자 검사: 문자가 조건에 맞는지 검사하고 맞으면 0이 아닌 값을 반환함
1.2. 문자 변환: 문자를 소문자/대문자/ASCII코드로 변환한다.

2. string.h
2.1. 복사: source에서 문자를 복사해 destination에 붙인다. (옵션: num바이트만큼 복사 or 잘라내기, 처음 num개 문자 복사, 기존 문자열 변환 후 처음 num개 문자 복사)
2.2. 병합: source를 destination뒤에 붙인다. (옵션: 처음 num개의 문자 붙이기)
2.3. 비교: 두 개의 ptr(포인터)나 str을 비교한다. (옵션: 처음 num바이트/문자 비교. 기존 문자 재해석 후 비교)
2.4. 탐색: ptr, str(원본)에서 처음으로 value와 일치하는 문자의 주소를 반환한다. (옵션: 원본의 첫 num바이트에서만 탐색, 원본에서 마지막으로 value와 일치하는 문자 주소 반환, value가 아닌 문자의 처음 위치 반환)
2.5. 원본 문자열 변경: 원본 문자열을 구분자(delimiter)를 기준으로 분리해서 문자열의 포인터를 하나씩 반환한다. (종류: strtok, strtok_r, strsep)

3. strtok(문자열, "구분자") - 문자열을 분리하는 함수에 대해 알아보자
<details markdown="1">
<summary> 자세한 설명 보기 </summary>
  
이 함수는 문자열을 다 분리할 때가지 반복해서 호출해야 하는데, 아래와 같이 호출해야 한다.

`char* ptr = strtok("Monkey&D&Luffy", "&");`

strtok은 구분자 &를 찾아 \0(널 문자)로 바꾸고 Monkey를 가리키는 포인터를 반환한다.
이제 또 함수를 호출해야 하는데, 첫 번째 인자를 NULL이 되어야 한다. 특이하다

`strtok(NULL, "&");`

그러면 함수는 D&Luffy에서 구분자 &를 찾고, \0으로 바꾸고, D를 가리키는 포인터를 반환한다.

`strtok(NULL, "&");`

남은 문자열은 Luffy\0이기 때문에 Luffy를 가리키는 포인터를 반환한다

`strtok(NULL, "&");`

남은 문자열이 없기 때문에 함수는 NULL을 반환한다.

이런 특성으로 인해 for문 작성시 strtok은 조건식이 될 수 있다.

예시
```
for(char *p="12&345"; char *s=strtok(p,"&"); p=NULL) {printf("%s  ",s);
```
여기에서 strtok()의 첫번째 인자로 처음에는 문자열이 들어가지만 두번째 loop부터는 NULL이 들어간다

또한 문자열을 다 분리하면 strtok은 NULL을 반환하기 때문에 조건식이 거짓이 되므로 for문이 종료된다.
</details>

:pushpin: **8단원** 명령행 인자는 프로그램의 확장성에 어떤 도움이 될까요? 구체적인 예시를 떠올려보세요.
1. 프로그램의 확장성
**문제**: 시스템의 데이터 양, 트래픽 양, 복잡도가 증가하면서 이를 처리할 수 있는 방법이 있어야 한다.  
**확장성**: 확장성은 부하가 증가해도 좋은 성능을 유지하기 위한 전략을 의미한다. 그리고 **증가한 부하에 대처하는 시스템 능력을 설명하는데 사용하는 용어**이기도 하다. **시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가?, 추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까?** 와 같은 질문을 고려한다는 의미이다. 
<details markdown="1">
<summary> 자세한 설명 보기 </summary>

글 출처: [신뢰성, 확장성, 유지보수성 자세한 설명](https://hojak99.tistory.com/644)  

**부하 매개변수**: 특정 기능 또는 웹 서버의 **초당 요청 수, DB의 읽기/쓰기 비율, 동시 활성 사용자 수, 캐시 적중률** 등
- 매개변수를 이용한 부하 성장 질문 예시
	- 부하 매개변수를 증가시키고 시스템 자원(CPU, 메모리, 네트워크 대역폭 등)은 변경하지 않을 때 시스템 성능은 어떻게 영향을 받을까?
	- 부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되길 원한다면 자원을 많이 늘려야 할까?

**성능 기술**: 시스템마다 성능에 대한 관점이 다르다. 예를 들어
- 일괄 처리 시스템의 주요 성능: 처리량
- 온라인 시스템의 주요 성능: 응답 시간   -> 온라인 시스템을 기준으로 설명해봄
	- 클라이언트의 동일한 요청에 대한 응답시간은 매번 다르다. 따라서 응답시간은 측정 가능한 값의 분포이다. 
	- 따라서 **특정 기능의 응답 시간은 어떻게 되나요?**와 같은 질문에 평균 1초 걸립니다와 같은 평균보다는 **99분위 응답 시간은 0.7초 입니다**와 같이 백분위를 이용해 대답하는 것이 좋다. 위 응답의 뜻은 100개의 요청 중 99개의 요청에 대한 응답은 0.7초 이하로 걸리고, 나머지 1개의 요청은 0.7초를 초과한다는 것이다. 

**확장성**
- **스케일업**(수직 스케일링): 기존의 서버를 더 높은 사양으로 업그레이드하는 것. 하나의 서버에 디스크를 추가하거나 CPU나 메모리를 업그레이드 시키는 것. DB를 분산해야 한다는 요구가 있기 전까진 스케일업을 하는 것이 일반적
- **스케일아웃**(수평 스케일링): 장비를 추가해서 확장하는 방식. 클라우드 서비스에서는 자원 사용량을 모니터링하여 자동으로 서버를 증설하는 Auto Scaling 기능도 있다. stateless한 서비스를 스케일아웃하는 것은 쉽지만 DB와 같은 시스템은 추가적으로 많은 복잡도가 발생해 잘 하지 않음. 
</details>

2. 명령행 인자가 프로그램 확장성에 어떤 도움이 될까?
잘은 모르지만..
명령행 인자는 가장 상위 단계(프로그램을 가동시키기 전에 인자 입력)에서 입력되는 정보이다. 따라서 함수 프로토타입을 int main()을 입력하기 전에 선언해서 본문에서 편하게 사용자 정의 함수를 사용하는 것과 마찬가지로, 코드가 어떻게 확장되거나 변형되는지와 관계없이 명령행 인자 값을 편히 사용할 수 있다. 이런 점이 확장성에 도움이 된다고 생각한다. 

 ##2. 참고 사이트
 1. [CS50 Manual Pages](https://manual.cs50.io/): C에서 쓰는 라이브러리와 그 함수를 정리해놓은 곳. 초보자 맞춤형이다.
 2. [Style Guide for C - CS50](https://cs50.readthedocs.io/style/c/): 바람직한 코드 디자인을 알려줌
